<!DOCTYPE html>
<html>
  <head>
     
    <meta charset="UTF-8">
    <title>MySQL1 - 测开、Java后端最常见、最核心的面试题总结</title>
    <link rel="shortcut icon" href="/static/img/icon.png">
    <link rel="icon" href="/static/img/icon.png" sizes="192x192"/>
    
<link rel="stylesheet" href="/static/kico.css">
<link rel="stylesheet" href="/static/hingle.css">

    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <meta name="viewport" content="width=device-width, maximum-scale=1, initial-scale=1"/>
    <meta property="og:site_name" content="测开、Java后端最常见、最核心的面试题总结">
    <meta property="og:title" content="MySQL1"/>
    
<meta name="generator" content="Hexo 7.3.0"></head>

  <body>
    <header>
    <div class="head-title">
        <h4>测开、Java后端最常见、最核心的面试题总结</h4>
    </div>
    <div class="head-action">
        <div class="toggle-btn"></div>
        <div class="light-btn"></div>
        <div class="search-btn"></div>
    </div>
    <form class="head-search" method="post">
        <input type="text" name="s" placeholder="搜索什么？">
    </form>
    <nav class="head-menu">
        <a href="/">首页</a>
        
    </nav>
</header>

    <main>
    <div class="wrap min">
        <section class="post-title">
            <h2>MySQL1</h2>
            <div class="post-meta">
                <time class="date">2024.07.21</time>
            
            </div>
        </section>
        <article class="post-content">
        
            <h1><span id="1什么是-mysql">1.什么是 MySQL？</span></h1><p>MySQL 是一个开源的关系型数据库管理系统，主要用于持久化存储我们的系统中的一些数据。现在隶属于 Oracle 旗下，也是我用得最多的一款关系型数据库。与此同时，MySQL 也是国内使用频率最高的一种数据库，MySQL 的默认端口号是<strong>3306</strong>。</p>
<h1><span id="2mysql-有什么优点">2.MySQL 有什么优点？</span></h1><p>MySQL 主要具有下面这些优点：</p>
<ol>
<li>成熟稳定，功能完善。</li>
<li>开源免费。</li>
<li>文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li>
<li>开箱即用，操作简单，维护成本低。</li>
<li>兼容性好，支持常见的操作系统，支持多种开发语言。</li>
<li>社区活跃，生态完善。</li>
<li>事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li>
<li>支持分库分表、读写分离、高可用。</li>
</ol>
<h1><span id="3mysql-字段类型">3.MySQL 字段类型</span></h1><p>MySQL 字段类型可以简单分为三大类：</p>
<ul>
<li><strong>数值类型</strong>：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）</li>
<li><strong>字符串类型</strong>：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。</li>
<li><strong>日期时间类型</strong>：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。</li>
</ul>
<h1><span id="4说一下数据库的三大范式">4.说一下数据库的三大范式？</span></h1><p>三大范式的作用是为了减少数据冗余，提高数据完整性。</p>
<p>①、第一范式（1NF）：确保表的每一列都是不可分割的基本数据单元，比如说用户地址，应该拆分成省、市、区、详细信息等。</p>
<p>②、第二范式（2NF）：在 1NF 的基础上，要求数据库表中的每一列都和主键直接相关，而不能只与主键的某一部分相关。</p>
<p>③、第三范式（3NF）：在 2NF 的基础上，消除非主键列对主键的传递依赖，即非主键只依赖于主键，不依赖于其他非主键。</p>
<p>在实际开发过程中，三大范式有时候反而成为阻碍，让表的设计变得复杂而又啰嗦，如果把一些可能不遵循三大范式的数据放在同一张表中可以减少额外的 JOIN 操作，提高查询效率。</p>
<h1><span id="5varchar-与-char-的区别">5.varchar 与 char 的区别？</span></h1><p><strong>char</strong>：</p>
<ul>
<li>char 表示定长字符串，长度是固定的；</li>
<li>如果插入数据的长度小于 char 的固定长度时，则用空格填充；</li>
<li>因为长度固定，所以存取速度要比 varchar 快很多，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li>
<li>对于 char 来说，最多能存放的字符个数为 255。</li>
</ul>
<p><strong>varchar</strong>：</p>
<ul>
<li>varchar 表示可变长字符串，长度是可变的；</li>
<li>插入的数据是多长，就按照多长来存储；</li>
<li>varchar 在存取方面与 char 相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li>
<li>对于 varchar 来说，最多能存放的字符个数为 65532</li>
</ul>
<p>日常的设计，对于长度相对固定的字符串，可以使用 char，对于长度不确定的，使用 varchar 更合适一些。</p>
<h1><span id="6介绍一下-mysql-的常用命令">6.介绍一下 MySQL 的常用命令</span></h1><p><strong>数据库操作命令：</strong></p>
<p>①、<strong>创建数据库</strong>:<code>CREATE DATABASE database_name;</code></p>
<p>②、<strong>删除数据库</strong>:<code>DROP DATABASE database_name;</code></p>
<p>③、<strong>选择数据库</strong>:<code>USE database_name;</code></p>
<p><strong>表操作命令：</strong> </p>
<p>①、<strong>创建表</strong>:<code>CREATE TABLE table_name (column1 datatype,column2 datatype, ...);</code></p>
<p>②、<strong>删除表</strong>:<code>DROP TABLE table_name;</code></p>
<p>③、<strong>显示所有表</strong>:<code>SHOW TABLES;</code></p>
<p>④、<strong>查看表结构</strong>:<code>DESCRIBE table_name;</code></p>
<p>⑤、<strong>修改表</strong>（添加列）:<code>ALTER TABLE table_name ADD column_name datatype;</code></p>
<p> <strong>CRUD 命令：</strong></p>
<p>①、<strong>插入数据</strong>:<code>INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);</code></p>
<p>②、<strong>查询数据</strong>:<code>SELECT column_names FROM table_name WHERE condition;</code></p>
<p>③、<strong>更新数据</strong>:<code>UPDATE table_name SET column1 = value1, column2 = value2 WHERE condition;</code></p>
<p>④、<strong>删除数据</strong>:<code>DELETE FROM table_name WHERE condition;</code></p>
<p><strong>索引和约束的创建修改命令：</strong></p>
<p>①、<strong>创建索引</strong>:<code>CREATE INDEX index_name ON table_name (column_name);</code></p>
<p>②、<strong>添加主键约束</strong>:<code>ALTER TABLE table_name ADD PRIMARY KEY (column_name);</code></p>
<p>③、<strong>添加外键约束</strong>:<code>ALTER TABLE table_name ADD CONSTRAINT fk_name FOREIGN KEY (column_name) REFERENCES parent_table (parent_column_name);</code></p>
<p><strong>用户和权限管理的命令：</strong></p>
<p>①、<strong>创建用户</strong>:<code>CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</code></p>
<p>②、<strong>授予权限</strong>:<code>GRANT ALL PRIVILEGES ON database_name.table_name TO &#39;username&#39;@&#39;host&#39;;</code></p>
<p>③、<strong>撤销权限</strong>:<code>REVOKE ALL PRIVILEGES ON database_name.table_name FROM &#39;username&#39;@&#39;host&#39;;</code></p>
<p>④、<strong>删除用户</strong>:<code>DROP USER &#39;username&#39;@&#39;host&#39;;</code></p>
<p><strong>事务控制的命令：</strong></p>
<p>①、<strong>开始事务</strong>:<code>START TRANSACTION;</code> <code>BEGIN;</code></p>
<p>②、<strong>提交事务</strong>:<code>COMMIT;</code></p>
<p>③、<strong>回滚事务</strong>:<code>ROLLBACK;</code></p>
<h1><span id="7count1-count-与-count列名-的区别">7.count(1)、count(*) 与 count(列名) 的区别？</span></h1><ol>
<li><code>COUNT(1)</code></li>
</ol>
<ul>
<li><strong>含义</strong>：统计查询结果中记录的总数，<code>1</code>在此处是一个常量。</li>
<li><strong>执行方式</strong>：数据库会为每一条记录都返回一个<code>1</code>，然后对这些<code>1</code>进行计数。</li>
<li><strong>使用场景</strong>：与<code>COUNT(*)</code>类似，用于统计表中符合条件的记录数。</li>
</ul>
<ol start="2">
<li><code>COUNT(*)</code></li>
</ol>
<ul>
<li><strong>含义</strong>：统计查询结果中记录的总数，不论列中是否包含<code>NULL</code>值。</li>
<li><strong>执行方式</strong>：数据库会将每一行都作为一个计数对象，不具体涉及表中的任何列。<code>COUNT(*)</code>对所有行进行计数，包括那些全为<code>NULL</code>的行。</li>
<li><strong>使用场景</strong>：最常用的统计总行数的方法，也是执行效率较高的一种方式，因为不需要检查每个字段的值。</li>
</ul>
<ol start="3">
<li><code>COUNT(列名)</code></li>
</ol>
<ul>
<li><strong>含义</strong>：统计指定列中非<code>NULL</code>值的数量。</li>
<li><strong>执行方式</strong>：数据库只对指定列中的非<code>NULL</code>值进行计数。<code>NULL</code>值不计入统计结果。</li>
<li><strong>使用场景</strong>：用于统计某一列中特定非<code>NULL</code>值的数量。例如，统计某个字段有多少条非<code>NULL</code>记录。</li>
</ul>
<p><strong>执行速度</strong>：</p>
<p>一般来说<code>count(*)</code>速度最快，因为数据库引擎在处理<code>COUNT(*)</code>时，不需要检查任何特定的列，也不需要解析列的值，只需统计行数。<code>COUNT(1)</code>与<code>COUNT(*)</code>几乎没有差别，现代数据库引擎对<code>COUNT(1)</code>和<code>COUNT(*)</code>通常进行相同的优化。<code>COUNT(列名)</code>通常比<code>COUNT(*)</code>和<code>COUNT(1)</code>稍慢，特别是当列包含<code>NULL</code>值时。因为数据库引擎需要遍历并检查该列的每个值，以排除<code>NULL</code>值。但是如果列名为主键，<code>COUNT(列名)</code>一般比另外两个更快。</p>
<h1><span id="8一条-sql-查询语句在-mysql-中如何执行的">8.一条 SQL 查询语句在 MySQL 中如何执行的？</span></h1><p>第一步，客户端发送 SQL 查询语句到 MySQL 服务器。</p>
<p>第二步，MySQL 服务器的连接器开始处理这个请求，跟客户端建立连接、获取权限、管理连接。</p>
<p>第三步（5.7之前还有，8.0 以后被移除了），连接建立后，MySQL 服务器的查询缓存组件会检查是否有缓存的查询结果。如果有，直接返回给客户端；如果没有，进入下一步。</p>
<p>第三步，解析器开始对 SQL 语句进行解析，检查语句是否符合 SQL 语法规则，确保引用的数据库、表和列都存在。</p>
<p>第四步，优化器负责确定 SQL 语句的执行计划，这包括选择使用哪些索引，以及决定表之间的连接顺序等。优化器会尝试找出最高效的方式来执行查询。</p>
<p>第五步，执行器会调用存储引擎的 API 来进行数据的读写。MySQL 的存储引擎是插件式的，不同的存储引擎在细节上面有很大不同。例如，InnoDB 是支持事务的，而 MyISAM 是不支持的。之后，会将执行结果返回给客户端</p>
<p>第六步，客户端接收到查询结果，完成这次查询请求。</p>
<h1><span id="9说说-mysql-的数据存储形式">9.说说 MySQL 的数据存储形式</span></h1><p>MySQL 是以表的形式存储数据的，而表空间的结构则由段、区、页、行组成。</p>
<p>① 段：表空间由多个段组成，常见的段有数据段、索引段、回滚段等。</p>
<p>创建索引时会创建两个段，数据段和索引段，数据段用来存储表中的行数据；索引段用来存储索引数据。回滚段存储事务的回滚信息。</p>
<p>② 区：段由一个或多个区组成，区是一组连续的页，通常包含 64 个连续的页，也就是 1M 的数据。</p>
<p>使用区而非单独的页进行数据分配可以优化磁盘操作，减少磁盘寻道时间，特别是在大量数据进行读写时。</p>
<p>③ 页：页是 InnoDB 存储数据的基本单元，标准大小为 16 KB，索引树上的一个节点就是一个页。</p>
<p>也就意味着数据库每次读写都是以 16 KB 为单位的，一次最少从磁盘中读取 16KB 的数据到内存，一次最少写入 16KB 的数据到磁盘。</p>
<p>④ 行：行是数据存储的最小单位，每行代表表中的一条记录。</p>
<h1><span id="10mysql-有哪些常见存储引擎">10.MySQL 有哪些常见存储引擎？</span></h1><p>MySQL 支持多种存储引擎，常见的有 MyISAM、InnoDB、MEMORY 等。MySQL 5.5 之前，默认存储引擎是 MyISAM，5.5 之后是 InnoDB。</p>
<h1><span id="11innodb-和-myisam-主要有什么区别">11.InnoDB 和 MyISAM 主要有什么区别？</span></h1><p>InnoDB 和 MyISAM 之间的区别主要表现在存储结构、事务支持、最小锁粒度、索引类型、主键必需、表的具体行数、外键支持等方面。</p>
<p><strong>①、存储结构</strong>：</p>
<ul>
<li>MyISAM：用三种格式的文件来存储，.frm 文件存储表的定义；.MYD 存储数据；.MYI 存储索引。</li>
<li>InnoDB：用两种格式的文件来存储，.frm 文件存储表的定义；.ibd 存储数据和索引。</li>
</ul>
<p><strong>②、事务支持</strong>：</p>
<ul>
<li>MyISAM：不支持事务。</li>
<li>InnoDB：支持事务。</li>
</ul>
<p><strong>③、最小锁粒度</strong>：</p>
<ul>
<li>MyISAM：表级锁，高并发中写操作存在性能瓶颈。</li>
<li>InnoDB：行级锁，并发写入性能高。</li>
</ul>
<p><strong>④、索引类型</strong>：</p>
<ul>
<li><p>MyISAM 为非聚簇索引，索引和数据分开存储，索引保存的是数据文件的指针。</p>
</li>
<li><p>InnoDB 为聚簇索引，索引和数据不分开。</p>
</li>
</ul>
<p><strong>⑤、外键支持</strong>：MyISAM 不支持外键；InnoDB 支持外键。</p>
<p><strong>⑥、主键必需</strong>：MyISAM 表可以没有主键；InnoDB 表必须有主键。</p>
<p><strong>⑦、表的具体行数</strong>：MyISAM 表的具体行数存储在表的属性中，查询时直接返回；InnoDB 表的具体行数需要扫描整个表才能返回。</p>
<h1><span id="12存储引擎应该怎么选择">12.存储引擎应该怎么选择？</span></h1><ul>
<li>大多数情况下，一般使用默认的 InnoDB ，InnoDB 可以提供事务、行级锁等能力。</li>
<li>MyISAM 适合读更多的场景。</li>
<li>MEMORY 适合临时表，数据量不大的情况。由于数据都存放在内存，所以速度非常快。</li>
</ul>
<h1><span id="13mysql-日志文件有哪些分别介绍下作用">13.MySQL 日志文件有哪些？分别介绍下作用？</span></h1><p>MySQL 的日志文件主要包括：</p>
<p>①、错误日志（Error Log）：记录 MySQL 服务器启动、运行或停止时出现的问题。</p>
<p>②、慢查询日志（Slow Query Log）：记录执行时间超过阈值的所有 SQL 语句。这个时间值是可配置的，默认情况下，慢查询日志功能是关闭的。可以用来识别和优化慢 SQL。</p>
<p>③、一般查询日志（General Query Log）：记录所有 MySQL 服务器的连接信息及所有的 SQL 语句，不论这些语句是否修改了数据。</p>
<p>④、<strong>二进制日志</strong>（Binary Log）：记录了所有修改数据库状态的 SQL 语句，以及每个语句的执行时间，如 INSERT、UPDATE、DELETE 等，但不包括 SELECT 和 SHOW 这类的操作。</p>
<p>⑤、<strong>重做日志</strong>（Redo Log）：记录了对于 InnoDB 表的每个写操作，不是 SQL 级别的，而是物理级别的，主要用于崩溃恢复。</p>
<p>⑥、回滚日志（Undo Log，或者叫事务日志）：记录数据被修改前的值，用于事务的回滚。</p>
<h1><span id="14请重点说说-binlog">14.请重点说说 binlog？</span></h1><p>binlog 是一种逻辑日志，记录了所有的DDL和DML语句，以事件形式记录，以便进行数据恢复和主从复制。</p>
<ul>
<li>当发生数据丢失时，binlog 可以将数据库恢复到特定的时间点。</li>
<li>主服务器（master）上的二进制日志可以被从服务器（slave）读取，从而实现数据同步。</li>
</ul>
<p>binlog 包括两类文件：</p>
<ul>
<li>二进制索引文件：用于存储所有二进制日志文件的列表</li>
<li>二进制日志文件：实际存储数据库修改操作的文件</li>
</ul>
<p>binlog 默认是没有启用的。要启用它，需要在 MySQL 的配置文件（my.cnf 或 my.ini）中设置 log_bin 参数。</p>
<p>参数包括是否启用，每个 binlog 文件的最大大小、binlog 文件的自动过期时间等。</p>
<h1><span id="15binlog-和-redo-log-有什么区别">15.binlog 和 redo log 有什么区别？</span></h1><p>binlog，即二进制日志，对所有存储引擎都可用，是 MySQL 服务器级别的日志，用于数据的复制、恢复和备份。而 redo log 主要用于保证事务的持久性，是 InnoDB 存储引擎特有的日志类型。</p>
<p>binlog 记录的是逻辑 SQL 语句，而 redo log 记录的是物理数据页的修改操作，不是具体的 SQL 语句。</p>
<p>redo log 是固定大小的，旧的日志会在空间需要时被覆盖。binlog 是追加写入的，新的事件总是被添加到当前日志文件的末尾，当文件达到一定大小后，会创建新的 binlog 文件继续记录。</p>
<h1><span id="16一条更新语句怎么执行的">16.一条更新语句怎么执行的？</span></h1><p><strong>1. 数据读取和更新</strong>：<br>当执行 <code>UPDATE</code> 语句时，执行器先向存储引擎请求数据。如果该数据已经在内存中（缓存在 InnoDB 的缓冲池中），则直接返回；否则，需要从磁盘读取数据到内存再返回给执行器。然后，执行器对数据进行更新，并将更新后的数据交给存储引擎。</p>
<p><strong>2. Redo Log 的准备阶段</strong><br>InnoDB 存储引擎会将更新操作记录到 Redo Log 中，并标记为 <code>prepare</code> 状态。此时数据已经在内存中被更新，Redo Log 也记录了这次操作，但尚未提交。</p>
<p><strong>3. Binlog 的生成与写入</strong>：<br>执行器生成 Binlog（记录逻辑上的 SQL 语句），并将其写入到磁盘。</p>
<p><strong>4. Redo Log 的提交阶段</strong>：<br>执行器调用存储引擎的提交接口，InnoDB 将之前处于 <code>prepare</code> 状态的 Redo Log 标记为 <code>commit</code>，完成整个更新操作的提交。两阶段提交的过程确保了 Binlog 和 Redo Log 之间的一致性。</p>
<h1><span id="17那为什么要两阶段提交呢">17.那为什么要两阶段提交呢？</span></h1><p>为什么要两阶段提交呢？直接提交不行吗？我们可以假设不采用两阶段提交的方式，而是采用“单阶段”进行提交，即要么先写入 redo log，后写入 binlog；要么先写入 binlog，后写入 redo log。这两种方式的提交都会导致原先数据库的状态和被恢复后的数据库的状态不一致。</p>
<p><strong>先写入 Redo Log，后写入 Binlog</strong></p>
<ul>
<li><strong>问题</strong>：如果在 Redo Log 写入之后，但在 Binlog 写入之前系统崩溃，那么在恢复过程中，系统会认为该事务已经提交（因为 Redo Log 是 <code>crash-safe</code> 的），但因为 Binlog 没有记录这个事务，数据库在恢复时会缺少这次操作。这导致数据库状态和崩溃前不一致。</li>
</ul>
<p><strong>先写入 Binlog，后写入 Redo Log</strong></p>
<ul>
<li><strong>问题</strong>：如果在 Binlog 写入之后但在 Redo Log 写入之前系统崩溃，Binlog 记录了事务提交的信息，所以在通过 Binlog 恢复数据时，数据会更新。但由于 Redo Log 没有记录这个操作，数据库在实际恢复过程中不会将这条操作应用到物理存储上。导致数据库恢复后，数据未被更新，造成数据不一致。</li>
</ul>
<p>两阶段提交机制保证了 Binlog 和 Redo Log 之间的状态是一致的，即事务的提交状态在两者中保持同步。这样在系统崩溃时，可以通过两者来确保数据一致性，无论是基于 Binlog 的恢复还是基于 Redo Log 的恢复，都能得到相同的结果。</p>
<h1><span id="18redo-log-怎么刷入磁盘的知道吗">18.redo log 怎么刷入磁盘的知道吗？</span></h1><p>redo log 的写入不是直接落到磁盘，而是在内存中设置了一片称之为<code>redo log buffer</code>的连续内存空间，也就是<code>redo 日志缓冲区</code>。</p>
<blockquote>
<p><strong>什么时候会刷入磁盘？</strong></p>
</blockquote>
<p>在如下的一些情况中，log buffer 的数据会刷入磁盘：</p>
<ul>
<li>log buffer 写满时</li>
<li>事务提交时</li>
<li>切换日志文件时</li>
<li>正常关闭服务器时</li>
<li><strong>触发 checkpoint 规则</strong></li>
</ul>
<blockquote>
<p>Redo Log 是一个循环日志，当所有日志文件都写满时，InnoDB 会回到第一个日志文件继续写。为了避免覆盖还没有被 checkpoint 刷入数据文件的数据，InnoDB 需要确保已经将旧的日志数据刷入磁盘，完成 checkpoint。Checkpoint 规则是在日志文件接近写满时，将内存中的脏页刷新到磁盘。</p>
</blockquote>

        </article>
        <section class="post-near">
            <ul>
                
                    <li>上一篇: <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/">计算机网络1</a></li>
                
                
                    <li>下一篇: 看完啦 (つд⊂)</li>
                
            </ul>
        </section>
        
    
        <section class="post-author">
        
            <figure class="author-avatar">
                <img src="https://sdn.geekzu.org/avatar/d22eb460ecab37fcd7205e6a3c55c228?s=200&r=X&d=" alt="Hingle" />
            </figure>
        
            <div class="author-info">
                <h4>Hingle</h4>
                <p>请在这里设置你的作者信息</p>
            </div>
        </section>
    
    </div>
</main>

    <footer>
    <div class="buttons">
        <a class="to-top" href="#"></a>
    </div>
    <div class="wrap min">
        <section class="widget">
            <div class="row">
                <div class="col-m-4">
                    <h3 class="title-recent">最新文章：</h3>
                    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/%E9%A1%B9%E7%9B%AE/">项目</a></li><li class="post-list-item"><a class="post-list-link" href="/MySQL2/">MySQL2</a></li><li class="post-list-item"><a class="post-list-link" href="/Java17%E6%96%B0%E7%89%B9%E6%80%A7/">Java17新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/Redis2/">Redis2</a></li><li class="post-list-item"><a class="post-list-link" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/">计算机网络2</a></li><li class="post-list-item"><a class="post-list-link" href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/">操作系统2</a></li></ul>
                </div>
            </div>
        </section>
        <section class="sub-footer">
            <p>© 2024 <a href="/">测开、Java后端最常见、最核心的面试题总结</a>. All Rights Reserved. Theme By <a href="https://github.com/Dreamer-Paul/Hingle" target="_blank" rel="nofollow">Hingle</a>.</p>
        </section>
    </div>
</footer>


<script src="/static/kico.js"></script>
<script src="/static/hingle.js"></script>


<script>var hingle = new Paul_Hingle({"copyright":false,"night":false});</script>

  </body>
</html>
