<!DOCTYPE html>
<html>
  <head>
     
    <meta charset="UTF-8">
    <title>测试基础 - 测开、Java后端最常见、最核心的面试题总结</title>
    <link rel="shortcut icon" href="/static/img/icon.png">
    <link rel="icon" href="/static/img/icon.png" sizes="192x192"/>
    
<link rel="stylesheet" href="/static/kico.css">
<link rel="stylesheet" href="/static/hingle.css">

    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <meta name="viewport" content="width=device-width, maximum-scale=1, initial-scale=1"/>
    <meta property="og:site_name" content="测开、Java后端最常见、最核心的面试题总结">
    <meta property="og:title" content="测试基础"/>
    
<meta name="generator" content="Hexo 7.3.0"></head>

  <body>
    <header>
    <div class="head-title">
        <h4>测开、Java后端最常见、最核心的面试题总结</h4>
    </div>
    <div class="head-action">
        <div class="toggle-btn"></div>
        <div class="light-btn"></div>
        <div class="search-btn"></div>
    </div>
    <form class="head-search" method="post">
        <input type="text" name="s" placeholder="搜索什么？">
    </form>
    <nav class="head-menu">
        <a href="/">首页</a>
        
    </nav>
</header>

    <main>
    <div class="wrap min">
        <section class="post-title">
            <h2>测试基础</h2>
            <div class="post-meta">
                <time class="date">2024.07.21</time>
            
            </div>
        </section>
        <article class="post-content">
        
            <h1><span id="1什么是软件测试">1.什么是软件测试？</span></h1><p>软件测试是为了发现错误而执行程序的过程。或者说，软件测试是根据软件开发各阶段的规格说明和程序的内部结构而精心设计一批测试用例(即输入数据及其预期的输出结果)，并利用这些测试用例去运行程序，以发现程序错误的过程。</p>
<h1><span id="2测试的目的">2.测试的目的</span></h1><p>测试的目的是想以最少的人力、物力和时间找出软件中潜在的各种错误和缺陷，通过修正错误和缺陷提高软件质量，回避软件发布后由于潜在的软件缺陷和错误造成的隐患带来的商业风险。</p>
<h1><span id="3测试种类">3.测试种类</span></h1><ul>
<li><strong>按开发阶段：</strong><ul>
<li><strong>单元测试</strong>：单元测试是对软件中的基本组成单位进行的测试，如一个模块、一个过程等等。它是软件动态测试的最基本的部分，也是最重要的部分之一，其目的是检验软件基本组成单位的正确性。主要用白盒测试。</li>
<li><strong>集成测试</strong>：集成测试是对软件系统中的多个模块或组件进行组合后的测试，目的是验证它们之间的交互是否正确，确保模块集成后能够协同工作。主要采用黑盒测试，辅之以白盒测试。</li>
<li><strong>系统测试</strong>：系统测试是对整个软件系统进行的全面测试，旨在验证系统的整体功能和性能，确保系统能够在实际环境中正常运行。仅仅应用黑盒测试。</li>
<li><strong>验收测试</strong>：验收测试是由最终用户或客户进行的测试，目的是验证软件是否满足业务需求和用户需求，是最终确认软件质量的关键步骤。</li>
</ul>
</li>
<li><strong>按测试实施组织：</strong><ul>
<li><strong>α测试：</strong>α测试是在开发阶段接近完成时进行的一种内部测试，由开发人员或内部测试团队执行，主要目的是发现并修复软件中的缺陷。这个阶段包括对功能、性能、用户界面等方面的测试，确保软件在更大范围的用户测试之前达到一定的稳定性和功能完整性。</li>
<li><strong>β测试：</strong>β测试是在α测试之后进行的外部测试，通常会邀请一部分实际用户来使用和测试软件。这一阶段的主要目的是在真实的用户环境中进行全面测试，收集用户反馈，发现潜在的缺陷和问题，以进一步完善软件，确保在正式发布前解决大部分问题，提升用户满意度。</li>
</ul>
</li>
<li><strong>按测试执行方式：</strong><ul>
<li><strong>静态测试：</strong>静态测试是在不运行程序的情况下对软件进行的一种测试方法，主要通过代码审查、静态分析、走查和技术评审等技术手段来检查和审阅代码、设计文档和需求规格说明书，以发现代码中的语法错误、逻辑缺陷和潜在问题。静态测试的目的是确保代码的质量和符合性，尽早在开发阶段发现和解决问题，从而减少后续测试阶段的工作量和缺陷修复成本。通常由开发人员、测试人员或专门的代码审查团队进行。</li>
<li><strong>动态测试：</strong>动态测试是在运行程序的情况下对软件进行的一种测试方法，通过实际执行代码来验证软件的功能、性能和可靠性。动态测试包括单元测试、集成测试、系统测试和验收测试等多个阶段，每个阶段都有其特定的测试目标和范围。单元测试主要验证单个模块或函数的正确性，集成测试验证多个模块或组件之间的交互，系统测试全面测试整个系统的功能和性能，而验收测试则由最终用户或客户进行，以验证软件是否满足业务需求和用户期望。动态测试的目的是发现软件在运行时的错误和缺陷，确保软件在各种使用条件下的正确性和稳定性。通常由测试人员、开发人员或实际用户进行。</li>
</ul>
</li>
<li><strong>按是否查看代码：</strong><ul>
<li><strong>黑盒测试：</strong>黑盒测试是一种测试方法，侧重于测试软件的功能而不关注其内部实现细节。在黑盒测试中，测试人员仅根据需求规格说明书和用户需求来设计测试用例，验证软件的输入和输出是否符合预期。此方法主要关注软件的功能、性能、兼容性和用户体验，常用于系统测试和验收测试，能够有效检查系统的功能是否按预期工作，而不需要了解代码的内部结构和逻辑。</li>
<li><strong>白盒测试：</strong>白盒测试是一种测试方法，侧重于测试软件的内部结构和实现细节。在白盒测试中，测试人员需要深入了解代码的结构、逻辑和算法，通过设计基于代码的测试用例，来验证代码的功能和实现是否符合要求。此方法包括代码审查、单元测试和路径测试等，能够检查代码的覆盖率、分支情况和潜在缺陷，通常由开发人员或测试人员进行，用于确保代码的正确性和质量。</li>
<li><strong>灰盒测试：</strong>灰盒测试是一种综合了黑盒测试和白盒测试的测试方法。测试人员在进行灰盒测试时，既考虑软件的内部实现细节，又关注功能和用户需求。通过部分了解系统内部结构和逻辑，设计测试用例以覆盖特定的功能点和实现细节，从而提高测试的全面性和有效性。灰盒测试通常用于集成测试和系统测试，能够有效识别功能和性能问题，同时揭示潜在的内部缺陷。</li>
</ul>
</li>
<li><strong>按是否手工执行划分：</strong><ul>
<li><strong>手工测试：</strong>手工测试是一种由测试人员手动执行测试用例并验证软件功能的方法。测试人员根据测试计划和测试用例逐步操作软件，记录结果并与预期结果进行对比，以发现潜在的缺陷和问题。手工测试特别适用于探索性测试和用户体验测试，因为它能够灵活应对复杂的使用场景和变化的需求。然而，手工测试通常较为耗时且容易受到人为因素的影响，难以重复执行同样的测试用例。</li>
<li><strong>自动化测试：</strong>自动化测试是一种通过编写测试脚本和使用自动化测试工具来执行测试用例的方法。自动化测试可以重复执行测试用例，快速验证软件功能，尤其适合进行回归测试、性能测试和大规模测试。自动化测试提高了测试效率和准确性，减少了人为错误，但初期设置和维护测试脚本的成本较高，适用于稳定且重复的测试任务。自动化测试工具如Selenium、JUnit和TestNG等可以帮助自动化执行测试，并生成详细的测试报告。</li>
</ul>
</li>
<li><strong>按测试对象划分：</strong><ul>
<li><strong>功能测试：</strong>功能测试是验证软件是否按照需求规格说明书中的功能要求进行操作的测试。测试人员设计测试用例以检查软件的每个功能是否正常工作，确保所有的功能按预期执行，输入与输出匹配。此测试重点在于确认软件的功能是否符合用户需求，并且所有功能点在不同场景下都能正确运行。</li>
<li><strong>界面测试：</strong>界面测试是验证软件用户界面的可用性和视觉效果的测试。测试人员检查界面的布局、控件、颜色、字体和交互元素，确保它们符合设计规范，并且在不同的分辨率和设备上呈现一致的效果。此测试旨在提高用户体验，确保界面的友好性和一致性。</li>
<li><strong>性能测试：</strong>性能测试是评估软件在特定负载和环境条件下的响应时间、稳定性和资源消耗的测试。测试包括负载测试、压力测试和容量测试等，目的是识别系统的性能瓶颈，确保软件能够在高负载下正常工作，并满足性能要求。</li>
<li><strong>易用性测试：</strong>易用性测试是评估软件是否具有良好的用户体验的测试，关注用户操作的便捷性、直观性和满意度。测试人员通过用户访谈、任务分析和实际操作等方式，评估软件的界面设计、交互流程和用户反馈，以提升软件的可用性和用户满意度。</li>
<li><strong>安全测试：</strong>安全测试是检查软件系统中的安全漏洞、弱点和风险的测试，确保软件能够抵御各种潜在的安全威胁。测试包括漏洞扫描、渗透测试和代码审查等，目的是识别和修复安全漏洞，保护系统免受攻击，确保数据和系统的安全性。</li>
<li><strong>兼容性测试：</strong>兼容性测试是验证软件在不同硬件、操作系统、浏览器或设备上的兼容性和稳定性的测试。测试人员检查软件在各种环境条件下的表现，确保它能够正常运行并与各种平台和配置兼容，满足不同用户的需求。</li>
<li><strong>文档测试：</strong>需求文档测试是对需求文档进行的检查，确保文档准确反映用户需求、逻辑严谨且一致，同时评估所描述的功能和需求在技术上是否可实现。这一测试过程帮助验证需求是否完整、合理并且能够在实际开发中得以实现。</li>
<li><strong>安装测试：</strong>安装测试是验证软件在不同环境下的安装和配置过程是否顺利、正确的测试。测试人员检查软件的安装程序是否能在不同操作系统和环境中成功安装，确认安装过程中的所有步骤和配置是否符合预期，确保用户能够顺利完成软件安装。</li>
<li><strong>弱网测试：</strong>弱网测试是评估软件在网络条件差、带宽有限或延迟较高的环境下的表现的测试。测试人员模拟低带宽、网络延迟和不稳定的网络条件，检查软件的网络请求、数据传输和用户体验，以确保在不理想的网络环境下仍能正常工作并提供良好的用户体验。</li>
</ul>
</li>
<li><strong>其他测试：</strong><ul>
<li><strong>回归测试：</strong>回归测试是一种测试方法，旨在验证软件在修改、更新或修复缺陷后，原有的功能是否仍然正常工作。测试人员会重新运行先前的测试用例，特别是那些可能受到代码变更影响的部分，以确保新的更改没有引入新的错误或破坏现有功能。回归测试是维护软件质量和稳定性的关键步骤，通常在每次代码变更后进行。</li>
<li><strong>冒烟测试：</strong>冒烟测试是一种初步测试，目的是快速检查软件的基本功能是否正常，确保新版本或新构建的代码没有重大问题或致命错误。冒烟测试通常只覆盖核心功能和关键路径，测试用例简单、快速执行，用以确定软件是否稳定到可以进行进一步的深入测试。它是质量保证过程中常用的快速反馈机制。</li>
<li><strong>随机测试：</strong>随机测试是一种测试方法，通过随机生成输入数据或随机选择操作序列来测试软件系统的行为。测试人员不预先设计具体的测试用例，而是利用随机或伪随机的方法进行测试，以发现潜在的缺陷和异常情况。随机测试适用于探索性测试，帮助识别在常规测试中可能未覆盖到的问题。</li>
</ul>
</li>
</ul>
<h1><span id="4驱动模块和桩模块">4.驱动模块和桩模块</span></h1><p><strong>驱动模块：</strong>驱动模块在大多数场合称为”主程序”，它接收测试数据并将这些数据传递到被测试模块.单元测试一个函数单元时，被测单元本身是不能独立运行的，需要为其传送数据，为此写驱动<br>驱动模块主要完成以下事情：<br>1、接受测试输入;<br>2、对输入进行判断;<br>3、将输入传给被测单元，驱动被测单元执行;<br>4、接受被测单元执行结果，并对结果进行判断;<br>5、将判断结果作为用例执行结果输出测试报告。</p>
<p><strong>桩模块：</strong>比如对函数A做单元测试时，被测的函数单元下还包括了一个函数B，为了更好的测试，定位错误，就要为函数B写桩，来模拟函数B的功能，保证其正确。</p>
<h1><span id="5黑盒与白盒测试方法用例设计方法">5.黑盒与白盒测试方法（用例设计方法）</span></h1><p>黑盒：等价类划分法、边界值法、错误推测法、流程图分析法、因果图、判定表法、正交试验法等</p>
<p>白盒： 语句覆盖 、判定覆盖 、条件覆盖、判定&#x2F;条件覆盖 、组合覆盖、路径覆盖 、分支覆盖等</p>
<h1><span id="6测试阶段包括哪些">6.测试阶段包括哪些？</span></h1><p>大体上来说可分为单元测试，集成测试，系统测试，验收测试，每个阶段又分为以下五个步骤: 测试计划，测试设计，用例设计，执行结果，测试报告。</p>
<h1><span id="7测试用例编写">7.测试用例编写</span></h1><p>​		首先是依据需求梳理功能及功能点。简而言之，就是根据需求规格说明书文档、原型图、UI 设计图等把能看得到的功能及功能点梳理出来。一些不明确的需求细节需要及时跟产品确认。<br>​		其次是通过测试理论方法及经验，梳理测试点。我们需要同时具备测试理论方法和测试经验，才能较好地设计出一份全面可靠的测试用例。常见的测试用例设计方法包括：等价类划分、边界值分析、判定表、因果图、错误推测法、场景法、正交试验法、状态迁移法等。		最后还需要挖掘隐性需求，覆盖非功能测试层面，如易用性测试，兼容性测试等。</p>
<h1><span id="8测试流程">8.测试流程</span></h1><ol>
<li><strong>需求分析</strong>：理解和分析用户需求和功能规格，确定测试需求。</li>
<li><strong>测试计划</strong>：制定详细的测试计划，明确测试的范围、策略和资源安排。</li>
<li><strong>测试设计</strong>：设计详细的测试用例和测试脚本，确保覆盖所有需求。</li>
<li><strong>测试环境准备</strong>：搭建并配置测试所需的软硬件环境。</li>
<li><strong>测试执行</strong>：执行测试用例，记录测试结果。</li>
<li><strong>缺陷管理</strong>：跟踪和管理测试过程中发现的缺陷，确保缺陷得到修复。</li>
<li><strong>回归测试</strong>：在修复缺陷后，验证软件的其他功能是否仍然正常工作。</li>
<li><strong>测试评估和总结</strong>：评估测试的效果和覆盖率，总结测试过程中的经验教训。</li>
<li><strong>测试关闭</strong>：结束测试活动，保存所有测试相关文档和结果，进行测试回顾。</li>
</ol>
<h1><span id="9测试用例要素">9.测试用例要素</span></h1><p>测试用例的要素有：1.用例编号；2.测试项目；3.测试标题；.4.重要级别；.5.预置条件；6.测试输入；7.操作步骤；8.预期结果。</p>
<h1><span id="10软件的缺陷等级">10.软件的缺陷等级</span></h1><p>软件缺陷的等级可以用严重性和优先级来描述；<br>严重性：衡量缺陷对客户满意度影响的满意程度，分为<br>1.致命错误，可能导致本模块以及其他相关的模块异常，死机等问题；<br>2.严重错误，问题局限在本模块，导致模块功能失常或异常退出；<br>3.一般错误，模块功能部分失效；<br>4.建议模块，有问题提出人对测试模块的改进建议；</p>
<p>优先级：缺陷被修复的紧急程度，分为<br>1.立即解决（P1级）：缺陷导致系统功能几乎不能使用或者测试不能继续，需立即修复；<br>2.高优先级（P2级）：缺陷严重，影响测试，需优先考虑；<br>3.正常排队（P3级）：缺陷需要正常排队等待修复；<br>4.低优先级（P4级）：缺陷可以在有时间的时候被纠正；</p>
<h1><span id="11哪些功能可以用自动化来进行">11.哪些功能可以用自动化来进行</span></h1><p>需求稳定，任务测试明确，不会频繁变更<br>研发和测试周期长，需要频繁执行回归测试<br>某些测试项目手工成本太高<br>软件系统界面稳定，变动少<br>需要在多平台上运行的相同测试案例，组合遍历型的测试，以及大量的重复任务<br>软件维护周期长<br>项目进度压力不太大</p>
<h1><span id="12常用测试工具">12.常用测试工具</span></h1><ol>
<li>单元测试工具：JUnit，PyTest等</li>
<li>API测试工具：Postman，Swagger等</li>
<li>性能测试工具：JMeter等</li>
<li>自动化测试工具：Selenium、Appium等</li>
<li>抓包工具：Fiddler、Charles</li>
<li>生成自动化测试报告：Allure</li>
</ol>
<h1><span id="13测试模型">13.测试模型</span></h1><p>软件测试模型是指在软件测试过程中使用的一些结构化方法或框架，用以指导测试活动的执行</p>
<ol>
<li><p><strong>瀑布模型：</strong></p>
<ul>
<li><strong>简介</strong>：瀑布模型是一种线性顺序的开发模型，其中每个阶段依次进行，前一个阶段的输出作为下一个阶段的输入。测试活动在开发过程的最后阶段进行。</li>
<li><strong>优点</strong>：简单易懂，适用于需求明确且变动较小的项目。</li>
<li><strong>缺点</strong>：缺乏灵活性，无法很好地应对需求变化，测试和开发严重依赖前序阶段的输出。</li>
</ul>
</li>
<li><p><strong>V模型：</strong></p>
<ul>
<li><strong>简介</strong>：V模型是一种扩展的瀑布模型，强调开发和测试的并行进行。每个开发阶段都有相应的测试阶段，从需求分析开始，逐步进行系统设计、详细设计、编码、单元测试、集成测试、系统测试和验收测试。</li>
<li><strong>优点</strong>：测试活动从项目早期开始，发现缺陷的时间较早，测试与开发紧密结合。</li>
<li><strong>缺点</strong>：同样缺乏灵活性，适用于需求明确且变动较小的项目。</li>
</ul>
</li>
<li><p><strong>W模型：</strong></p>
<ul>
<li><strong>简介</strong>：W模型在V模型的基础上，增加了更多的测试活动和检查点，使得测试工作贯穿于整个软件开发生命周期的每个阶段。W模型的形状类似于字母”W”，展示了每个开发阶段都对应着一个或多个测试活动。</li>
<li><strong>优点</strong>：测试活动从项目早期开始，发现缺陷的时间较早，测试与开发紧密结合，通过在每个阶段进行测试，确保每个阶段的输出都符合预期，提高了产品的质量。</li>
<li><strong>缺点</strong>：增加了工作量，实施复杂。</li>
</ul>
</li>
<li><p><strong>原型模型：</strong></p>
<ul>
<li><strong>简介</strong>：原型模型是一种迭代开发模型，通过构建一个或多个原型来逐步完善需求和设计，最终形成最终产品。测试活动贯穿于每个原型的开发过程中。</li>
<li><strong>优点</strong>：能够更好地理解和明确用户需求，适应需求变化。</li>
<li><strong>缺点</strong>：可能导致过度开发原型，增加项目成本和时间。</li>
</ul>
</li>
<li><p><strong>增量模型：</strong></p>
<ul>
<li><strong>简介</strong>：增量模型是一种分阶段的开发模型，软件系统通过一系列增量（小版本）逐步交付，每个增量包括部分功能的开发、测试和交付。每个增量在完成后都要进行测试。</li>
<li><strong>优点</strong>：可以逐步交付产品，适应需求变化，减少风险。</li>
<li><strong>缺点</strong>：需要良好的计划和管理，可能导致每个增量之间的集成复杂度增加。</li>
</ul>
</li>
<li><p><strong>螺旋模型：</strong></p>
<ul>
<li><strong>简介</strong>：螺旋模型是一种风险驱动的迭代开发模型，每个迭代周期包括规划、风险分析、开发和验证。测试活动在每个迭代周期内进行。</li>
<li><strong>优点</strong>：强调风险管理和渐进式交付，适应复杂和高风险项目。</li>
<li><strong>缺点</strong>：模型复杂，管理和实施成本较高。</li>
</ul>
</li>
<li><p><strong>敏捷模型</strong>：</p>
<ul>
<li><strong>简介</strong>：敏捷模型是一种灵活的开发模型，强调快速交付、持续改进和用户反馈。常见的敏捷方法包括Scrum、XP等，测试活动贯穿于整个开发周期，通常采用测试驱动开发（TDD）和持续集成（CI）等实践。</li>
<li><strong>优点</strong>：高度灵活，能够快速响应需求变化，强调团队协作和用户反馈。</li>
<li><strong>缺点</strong>：需要高水平的团队协作和自律，可能难以在大型组织中实施。</li>
</ul>
</li>
</ol>
<h1><span id="14web测试和app测试的不同点">14.web测试和app测试的不同点</span></h1><p><strong>系统架构方面：</strong></p>
<p>web项目，一般都是b&#x2F;s架构，基于浏览器的</p>
<p>app项目，则是c&#x2F;s的，必须要有客户端，用户需要安装客户端。</p>
<p>web测试只要更新了服务器端，客户端就会同步会更新。App项目则需要客户端和服务器都更新。</p>
<p><strong>性能方面:</strong></p>
<p>web页面主要会关注响应时间</p>
<p>而app则还需要关心流量、电量、CPU、GPU、Memory这些。</p>
<p>它们服务端的性能没区别，都是一台服务器。</p>
<p><strong>兼容方面：</strong></p>
<p>web是基于浏览器的，所以更倾向于浏览器和电脑硬件，电脑系统的方向的兼容</p>
<p>app测试则要看分辨率，屏幕尺寸，还要看设备系统。</p>
<p>web测试是基于浏览器的所以不必考虑安装卸载。</p>
<p>而app是客户端的，则必须测试安装、更新、卸载。除了常规的安装、更新、卸载还要考虑到异常场景。包括安装时的中断、弱网、安装后删除安装文件 。</p>
<p>此外APP还有一些专项测试：如网络、适配性。</p>
<h1><span id="15如何对淘宝搜索框进行测试">15.如何对淘宝搜索框进行测试</span></h1><p><strong>一：功能测试</strong></p>
<ol>
<li><p>输入关键字，查看: 返回结果是否准确，返回的文本长度需限制<br>1.1输入可查到结果的正常关键字、词、语句，检索到的内容、链接正确性；<br>1.2输入不可查到结果的关键字、词、语句；<br>1.3输入一些特殊的内容，如空、特殊符、标点符、极限值等，可引入等价类划分的方法等；</p>
</li>
<li><p>结果显示：标题，卖家，销售量，单行&#x2F;多行，是否有图片</p>
</li>
<li><p>结果排序：价格 销量 评价 综合</p>
</li>
<li><p>返回结果庞大时，限制第一页的现实量，需支持翻页</p>
</li>
<li><p>多选项搜索：关键字 品牌 产地 价格区间 是否天猫 是否全国购</p>
</li>
<li><p>是否支持模糊搜索，支持通配符的查询</p>
</li>
<li><p>搜索结果为空的情况</p>
</li>
<li><p>未登录情况和登录情况下的搜索（登录情况下 存储用户搜索的关键字&#x2F;搜索习惯）</p>
</li>
</ol>
<p><strong>二：性能测试</strong></p>
<p>1 压力测试：在不同发用户数压力下的表现（评价指标如响应时间等）</p>
<p>2 负载测试：看极限能承载多大的用户量同时正常使用</p>
<p>3 稳定性测试：常规压力下能保持多久持续稳定运行</p>
<p>4 内存测试：有无内存泄漏现象</p>
<p>5 大数据量测试：如模拟从庞大的海量数据中搜索结果、或搜索出海量的结果后列示出来，看表现如何等等。</p>
<p><strong>三： 易用性：交互界面的设计是否便于、易于使用</strong></p>
<p>1 依据不同的查询结果会有相关的人性化提示，查不到时告知？查到时统计条数并告知？有疑似输入条件错误时提示可能正确的输入项等等处理；</p>
<p>2 查询出的结果罗列有序，如按点击率或其他排序规则，确保每次查询出的结果位置按规则列示方便定位，显示字体、字号、色彩便于识别等等；</p>
<p>3 标题查询、全文检索、模糊查询、容错查询、多关键字组织查询（空格间格开）等实用的检索方式是否正常？</p>
<p>4 输入搜索条件的控件风格设计、位置摆放是否醒目便于使用者注意到，有否快照等快捷查看方式等人性化设计？</p>
<p><strong>四：兼容性</strong></p>
<p>1 WINDOWS&#x2F;LINUX&#x2F;UNIX等各类操作系统下及各版本条件下的应用</p>
<p>2 IE&#x2F;FIREFOX&#x2F;GOOGLE&#x2F;360&#x2F;QQ等各类浏览器下及各版本条件下、各种显示分辨率条件下的应用</p>
<p>3 SQL&#x2F;ORACLE&#x2F;DB2&#x2F;MYSQL等各类数据库存储情况下的兼容性测试</p>
<p>4 简体中文、繁体中文、英文等各类语种软件平台下的兼容性测试</p>
<p>5 IPHONE&#x2F;IPAD、安卓等各类移动应用平台下的兼容性测试</p>
<p>6 与各相关的监控程序的兼容性测试，如输入法、杀毒、监控、防火墙等工具同时使用</p>
<p><strong>五：安全性</strong></p>
<p>1 被删除、加密、授权的数据，不允许被SQL注入等攻击方式查出来的，是否有安全控制设计；</p>
<p>2 录入一些数据库查询的保留字符，如单引号、%等等，造成查询SQL拼接出的语句产生漏洞，如可以查出所有数据等等；</p>
<p>3 通过白盒测试技术，检查一下在程序设计上是否存在安全方面的隐患；</p>
<p>4 对涉及国家安全、法律禁止的内容是否进行了相关的过滤和控制；</p>
<p><strong>六：弱网测试</strong></p>
<p>网速慢的情况下的搜索</p>
<h1><span id="16如果某用户头条app刷不出东西了应该怎么排查问题">16.如果某用户头条app刷不出东西了，应该怎么排查问题</span></h1><p>APP的设计是C&#x2F;S架构，是基于客户端的，所以，在排查问题时，应该考虑客户端和服务端两个方面。 </p>
<p>  <strong>对客户端来说：</strong> </p>
<p>  首先查看网络连接是否正确 </p>
<p>  其次查看设备缓存是否已满 </p>
<p>  再次是APP的版本问题，更新版本或卸载重新安装 </p>
<p>  再次抓包查看客户端的请求报文是否正确 </p>
<p>  <strong>对服务端来讲：</strong> </p>
<p>  首先查看服务器是否挂掉， </p>
<p>  其次查看系统负载情况，查看日志文件该用户是否有请求发送过来 </p>
<p>  再次对服务器的返回报文进行查看，是否正确</p>

        </article>
        <section class="post-near">
            <ul>
                
                    <li>上一篇: <a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/">操作系统1</a></li>
                
                
                    <li>下一篇: <a href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li>
                
            </ul>
        </section>
        
    
        <section class="post-author">
        
            <figure class="author-avatar">
                <img src="https://sdn.geekzu.org/avatar/d22eb460ecab37fcd7205e6a3c55c228?s=200&r=X&d=" alt="Hingle" />
            </figure>
        
            <div class="author-info">
                <h4>Hingle</h4>
                <p>请在这里设置你的作者信息</p>
            </div>
        </section>
    
    </div>
</main>

    <footer>
    <div class="buttons">
        <a class="to-top" href="#"></a>
    </div>
    <div class="wrap min">
        <section class="widget">
            <div class="row">
                <div class="col-m-4">
                    <h3 class="title-recent">最新文章：</h3>
                    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/%E9%A1%B9%E7%9B%AE/">项目</a></li><li class="post-list-item"><a class="post-list-link" href="/MySQL2/">MySQL2</a></li><li class="post-list-item"><a class="post-list-link" href="/Java17%E6%96%B0%E7%89%B9%E6%80%A7/">Java17新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/Redis2/">Redis2</a></li><li class="post-list-item"><a class="post-list-link" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/">计算机网络2</a></li><li class="post-list-item"><a class="post-list-link" href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/">操作系统2</a></li></ul>
                </div>
            </div>
        </section>
        <section class="sub-footer">
            <p>© 2024 <a href="/">测开、Java后端最常见、最核心的面试题总结</a>. All Rights Reserved. Theme By <a href="https://github.com/Dreamer-Paul/Hingle" target="_blank" rel="nofollow">Hingle</a>.</p>
        </section>
    </div>
</footer>


<script src="/static/kico.js"></script>
<script src="/static/hingle.js"></script>


<script>var hingle = new Paul_Hingle({"copyright":false,"night":false});</script>

  </body>
</html>
