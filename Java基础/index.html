<!DOCTYPE html>
<html>
  <head>
     
    <meta charset="UTF-8">
    <title>Java基础 - Java后端与测试核心面试题总结</title>
    <link rel="shortcut icon" href="/static/img/icon.png">
    <link rel="icon" href="/static/img/icon.png" sizes="192x192"/>
    
<link rel="stylesheet" href="/static/kico.css">
<link rel="stylesheet" href="/static/hingle.css">

    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <meta name="viewport" content="width=device-width, maximum-scale=1, initial-scale=1"/>
    <meta property="og:site_name" content="Java后端与测试核心面试题总结">
    <meta property="og:title" content="Java基础"/>
    
<meta name="generator" content="Hexo 7.3.0"></head>

  <body>
    <header>
    <div class="head-title">
        <h4>Java后端与测试核心面试题总结</h4>
    </div>
    <div class="head-action">
        <div class="toggle-btn"></div>
        <div class="light-btn"></div>
        <div class="search-btn"></div>
    </div>
    <form class="head-search" method="post">
        <input type="text" name="s" placeholder="搜索什么？">
    </form>
    <nav class="head-menu">
        <a href="/">首页</a>
        
    </nav>
</header>

    <main>
    <div class="wrap min">
        <section class="post-title">
            <h2>Java基础</h2>
            <div class="post-meta">
                <time class="date">2024.07.21</time>
            
            </div>
        </section>
        <article class="post-content">
        
            <h1><span id="1什么是java">1.什么是Java？</span></h1><p>Java 是一门面向对象的编程语言，Java 吸收了 C++ 语言中大量的优点，但又抛弃了 C++ 中容易出错的地方，如垃圾回收。</p>
<p>同时，Java 又是一门平台无关的编程语言，即一次编译，处处运行（Write Once，Run Anywhere），可以在 Windows、macOS、Linux 平台上运行，只需要安装一个 Java 虚拟机（JVM）。</p>
<h1><span id="2jvm-jre-和-jdk-有什么区别">2.JVM、JRE 和 JDK 有什么区别？</span></h1><p><strong>JVM</strong>：Java Virtual Machine，也就是 Java 虚拟机，是 Java 实现跨平台的关键所在，针对不同的操作系统，有不同的 JVM 实现。JVM 负责将 Java 字节码转换为特定平台的机器码并执行。</p>
<p><strong>JRE</strong>：Java Runtime Environment，也就是 Java 运行时环境，包含了运行 Java 程序所必需的库，以及 Java 虚拟机（JVM）。</p>
<p><strong>JDK</strong>：Java Development Kit，是一套完整的 Java SDK（软件开发工具包），包括了 JRE 以及编译器（javac）、Java 文档生成工具（Javadoc）、Java 调试器等开发工具。为开发者提供了开发、编译、调试 Java 程序的一整套环境。</p>
<p>简单来说，JDK 包含 JRE，JRE 包含 JVM。</p>
<h1><span id="3java-se-与-java-ee-的区别">3.Java SE 与 Java EE 的区别</span></h1><ul>
<li>Java SE（Java Platform，Standard Edition）: Java 平台标准版，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。</li>
<li>Java EE（Java Platform, Enterprise Edition ）：Java 平台企业版，建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、JDBC）。 Java EE 可以用于构建分布式、可移植、健壮和安全的服务端 Java 应用程序，例如 Web 应用程序。</li>
</ul>
<p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p>
<p>除了 Java SE 和 Java EE，还有一个 Java ME（Java Platform，Micro Edition）。Java ME 是 Java 的微型版本，主要用于开发嵌入式电子设备的应用程序，例如手机、PDA、机顶盒、冰箱、空调等。不过现在几乎不用了。</p>
<h1><span id="4什么是字节码">4.什么是字节码?</span></h1><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C、 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p>从编写Java代码到运行，整个过程包括：Java代码经 javac 编译生成字节码文件，JVM加载字节码文件，再通过解释器执行，有些方法和代码块可能会经常被调用，所以后面引入了JIT编译器，也就是即时编译器，当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>
<h1><span id="5java-中的几种基本数据类型了解么">5.Java 中的几种基本数据类型了解么？</span></h1><p>Java 中有 8 种基本数据类型，分别为：</p>
<ul>
<li>6 种数字类型： <ul>
<li>4 种整数型：<code>byte(1)</code>、<code>short(2)</code>、<code>int(4)</code>、<code>long(8)</code></li>
<li>2 种浮点型：<code>float(4)</code>、<code>double(8)</code></li>
</ul>
</li>
<li>1 种字符类型：<code>char(2)</code></li>
<li>1 种布尔型：<code>boolean()</code>。</li>
</ul>
<p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p>
<h1><span id="6float-是怎么表示小数的">6.float 是怎么表示小数的？</span></h1><p><code>float</code>类型的小数在计算机中是通过 IEEE 754 标准的单精度浮点数格式来表示的。</p>
<ul>
<li>S：符号位，0 代表正数，1 代表负数；</li>
<li>M：尾数部分，用于表示数值的精度；比如说 <code>1.25 * 2^2</code>；1.25 就是尾数；</li>
<li>R：基数，十进制中的基数是 10，二进制中的基数是 2；</li>
<li>E：指数部分，例如 10^-1 中的 -1 就是指数。</li>
</ul>
<p>这种表示方法可以将非常大或非常小的数值用有限的位数表示出来，但这也意味着可能会有精度上的损失。</p>
<p>单精度浮点数占用 4 字节（32 位），这 32 位被分为三个部分：符号位、指数部分和尾数部分。</p>
<ol>
<li><strong>符号位（Sign bit）</strong>：1 位</li>
<li><strong>指数部分（Exponent）</strong>：8 位</li>
<li><strong>尾数部分（Mantissa，或 Fraction）</strong>：23 位</li>
</ol>
<p>使用浮点数时需要注意，由于精度的限制，进行数学运算时可能会遇到舍入误差，对于需要高精度计算的场景（如金融计算），可能需要考虑使用<code>BigDecimal</code>类来避免这种误差。</p>
<h1><span id="7基本类型和包装类型的区别">7.基本类型和包装类型的区别</span></h1><p><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</p>
<p><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</p>
<p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p>
<p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p>
<p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p>
<h1><span id="8包装类型的缓存机制是什么">8.包装类型的缓存机制是什么？</span></h1><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<h1><span id="9自动装箱与拆箱了解吗原理是什么">9.自动装箱与拆箱了解吗？原理是什么？</span></h1><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>如果频繁拆装箱的话，会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作</p>
<h1><span id="10重载和重写的区别">10.重载和重写的区别？</span></h1><p><strong>重载：</strong><br>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p><strong>重写：</strong></p>
<p>重写发生在运行期，是子类对父类的允许访问的方法进行重新编写。</p>
<ol>
<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<h1><span id="11深拷贝和浅拷贝区别了解吗">11.深拷贝和浅拷贝区别了解吗？</span></h1><ul>
<li><strong>浅拷贝</strong>：仅拷贝被拷贝对象的成员变量的值，也就是基本数据类型变量的值，和引用数据类型变量的地址值，而对于引用类型变量指向的堆中的对象不会拷贝。</li>
<li><strong>深拷贝</strong>：完全拷贝一个对象，拷贝被拷贝对象的成员变量的值，堆中的对象也会拷贝一份。</li>
</ul>
<h1><span id="12x3dx3d-和-equals-的区别">12.&#x3D;&#x3D; 和 equals() 的区别</span></h1><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true。</li>
</ul>
<h1><span id="13为什么要有-hashcode-方法">13.为什么要有 hashCode 方法？</span></h1><p>hashCode 方法主要用来获取对象的哈希码，哈希码是由对象的内存地址或者对象的属性计算出来的，它是⼀个 int 类型的整数，通常是不会重复的，因此可以用来作为键值对的键，以提高查询效率。<br>一般重写equals()方法的同时也要重写hashCode()方法，维护 <code>equals()</code>和 <code>hashCode()</code>之间的一致性是至关重要的，因为基于哈希的集合类（如 HashSet、HashMap、Hashtable 等）依赖于这一点来正确存储和检索对象。如果重写了 <code>equals()</code>方法而没有重写 <code>hashCode()</code>方法，那么被认为相等的对象可能会有不同的哈希码，从而导致无法在集合中正确处理这些对象。</p>
<h1><span id="14java创建对象有几种方式">14.Java创建对象有几种方式？</span></h1><p>Java 有四种创建对象的方式：</p>
<p>①、new 关键字创建，这是最常见和直接的方式，通过调用类的构造方法来创建对象。</p>
<p>②、反射机制创建，反射机制允许在运行时创建对象，并且可以访问类的私有成员，在框架和工具类中比较常见。</p>
<p>③、clone 拷贝创建，通过 clone 方法创建对象，需要实现 Cloneable 接口并重写 clone 方法。</p>
<p><code>Person person = new Person(); Person person2 = (Person) person.clone();</code></p>
<p>④、序列化机制创建，通过序列化将对象转换为字节流，再通过反序列化从字节流中恢复对象。需要实现 Serializable 接口。</p>
<h1><span id="15string-和-stringbuilder-stringbuffer-的区别">15.String 和 StringBuilder、StringBuffer 的区别？</span></h1><p><code>String</code>、<code>StringBuilder</code>和<code>StringBuffer</code>在 Java 中都是用于处理字符串的，它们之间的区别是，String 是不可变的，平常开发用得最多，当遇到大量字符串连接时，就用 StringBuilder，它不会生成很多新的对象，StringBuffer 和 StringBuilder 类似，但每个方法上都加了 synchronized 关键字，所以是线程安全的。</p>
<h1><span id="16string-s1-x3d-new-stringabc这句话创建了几个字符串对象">16.String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</span></h1><p>会创建 1 或 2 个字符串对象。</p>
<p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。</p>
<p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p>
<h1><span id="17stringintern-方法有什么作用">17.String.intern 方法有什么作用?</span></h1><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<h1><span id="18java中的异常处理体系">18.Java中的异常处理体系</span></h1><p><code>Throwable</code> 是 Java 语言中所有错误和异常的基类。它有两个主要的子类：Error 和 Exception。</p>
<ul>
<li><p>Error 类代表那些严重的错误，这类错误通常是程序无法处理的。比如，OutOfMemoryError 表示内存不足，StackOverflowError 表示栈溢出。这些错误通常与 JVM 的运行状态有关，一旦发生，应用程序通常无法恢复。</p>
</li>
<li><p>Exception 类代表程序可以处理的异常。它分为两大类：编译时异常（Checked Exception）和运行时异常（Runtime Exception）。</p>
<ul>
<li>①、编译时异常（Checked Exception）：这类异常在编译时必须被显式处理（捕获或声明抛出）。<br>如果方法可能抛出某种编译时异常，但没有捕获它（try-catch）或没有在方法声明中用 throws 子句声明它，那么编译将不会通过。例如：IOException、SQLException 等。</li>
<li>②、运行时异常（Runtime Exception）：这类异常在运行时抛出。对于运行时异常，Java 编译器不要求必须处理它们（即不需要捕获也不需要声明抛出）。运行时异常通常是由程序逻辑错误导致的，如 空指针异常、索引越界异常等。</li>
</ul>
</li>
</ul>
<h1><span id="19try-catch-finally-如何使用">19.try-catch-finally 如何使用？</span></h1><ul>
<li><code>try</code>块：用于包含可能会抛出异常的代码。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><code>catch</code>块：用于捕获并处理<code>try</code>块中抛出的异常。</li>
<li><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>
</ul>
<h1><span id="20java-io-流了解吗">20.Java IO 流了解吗？</span></h1><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>
<p>Java IO 流的 40 多个类都是从4 个抽象类基类中派生出来的：</p>
<ul>
<li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h1><span id="21ix2fo-流为什么要分为字节流和字符流呢">21.I&#x2F;O 流为什么要分为字节流和字符流呢?</span></h1><p>其实字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还比较耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h1><span id="22bio-nio-aio-之间的区别">22.BIO、NIO、AIO 之间的区别？</span></h1><p>BIO（Blocking I&#x2F;O）：也就是传统的 IO，基于字节流或字符流进行文件读写，基于 Socket 和 ServerSocket 进行网络通信。采用阻塞式 I&#x2F;O 模型，线程在执行 I&#x2F;O 操作时被阻塞，无法处理其他任务，适用于连接数较少的场景。</p>
<p>NIO（New I&#x2F;O 或 Non-blocking I&#x2F;O）：放在 java.nio 包下，提供了 Channel、Buffer、Selector 等新的抽象。采用非阻塞 I&#x2F;O 模型，线程在等待 I&#x2F;O 时可执行其他任务，通过 Selector 监控多个 Channel 上的事件，适用于连接数多但连接时间短的场景。</p>
<p>AIO（Asynchronous I&#x2F;O）：使用异步 I&#x2F;O 模型，线程发起 I&#x2F;O 请求后立即返回，当 I&#x2F;O 操作完成时通过回调函数通知线程，适用于连接数多且连接时间长的场景。</p>
<h1><span id="23什么是序列化什么是反序列化">23.什么是序列化？什么是反序列化？</span></h1><p>序列化（Serialization）是指将对象转换为字节流的过程，以便能够将该对象保存到文件、数据库，或者进行网络传输。</p>
<p>反序列化（Deserialization）就是将字节流转换回对象的过程，以便构建原始对象。</p>
<h1><span id="24说说有几种序列化方式">24.说说有几种序列化方式？</span></h1><ul>
<li>Java 原生序列化 ：通过<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>实现对象的序列化和反序列化。</li>
<li>Json 序列化：这个可能是我们最常用的序列化方式，Json 序列化的选择很多，一般会使用 jackson 包，通过 ObjectMapper 类来实现Java对象与Json格式之间的转换。</li>
<li>ProtoBuff 序列化：Protocol Buffers是Google开发的一种数据描述语言， 是一种轻便高效的结构化数据存储格式，ProtoBuff 序列化对象可以很大程度上将其压缩，可以大大减少数据传输大小，提高系统性能。</li>
</ul>
<h1><span id="25如果有些字段不想进行序列化怎么办">25.如果有些字段不想进行序列化怎么办？</span></h1><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。当对象被序列化时，<code>transient</code>关键字标记的字段会被忽略，不会包含在序列化的数据中。</p>
<p>关于 <code>transient</code> 还有几点注意：</p>
<ul>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
<li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>
<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>
</ul>
<h1><span id="26什么是泛型有什么作用">26.什么是泛型？有什么作用？</span></h1><p>Java 泛型是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发人员在编译时检测到非法的类型。泛型的本质是类型参数化，也就是说所操作的数据类型被指定为一个参数。</p>
<p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>
<h1><span id="27注解了解吗">27.注解了解吗？</span></h1><p>注解（<code>Annotation</code>） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p>
<p>JDK 提供了很多内置的注解（比如 <code>@Override</code>、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p>
<p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li>
</ul>
<h1><span id="28什么是反射应用原理">28.什么是反射？应用？原理？</span></h1><p>创建一个对象是通过 new 关键字来实现的，比如：</p>
<p><code>Person person = new Person();</code></p>
<p>Person 类的信息在编译时就确定了，那假如在编译期无法确定类的信息，但又想在运行时获取类的信息、创建类的实例、调用类的方法，这时候就要用到反射。</p>
<p>反射功能主要通过 <code>java.lang.Class</code> 类及 <code>java.lang.reflect</code> 包中的类如 Method, Field, Constructor 等来实现。</p>
<p><strong>反射应用场景</strong></p>
<p>①、Spring 框架就大量使用了反射来动态加载和管理 Bean。</p>
<p>②、Java 的动态代理（Dynamic Proxy）机制就使用了反射来创建代理类。代理类可以在运行时动态处理方法调用，这在实现 AOP 和拦截器时非常有用。</p>
<p>③、JUnit 等测试框架使用反射机制来发现和执行测试方法。反射允许框架扫描类，查找带有特定注解（如 <code>@Test</code>）的方法，并在运行时调用它们。</p>
<p><strong>反射原理</strong></p>
<p>我们都知道 Java 程序的执行分为编译和运行两步，编译之后会生成字节码(.class)文件，JVM 进行类加载的时候，会加载字节码文件，将类型相关的所有信息加载进方法区，反射就是去获取这些信息，然后进行各种操作</p>
<h1><span id="29lambda-表达式了解多少">29.Lambda 表达式了解多少？</span></h1><p>Lambda 表达式主要用于提供一种简洁的方式来表示匿名方法，使 Java 具备了函数式编程的特性。这比以前的匿名内部类要简洁很多。</p>
<p>所谓的函数式编程，就是把函数作为参数传递给方法，或者作为方法的结果返回。</p>
<h1><span id="30stream-流用过吗">30.Stream 流用过吗？</span></h1><p><code>Stream</code> 流，简单来说，就是使用 <code>Stream</code> 对一个包含一个或多个元素的集合做各种操作。这些操作可能是中间操作亦或是终端操作。 终端操作会返回一个结果，而中间操作会返回一个 <code>Stream</code> 流，所以可以进行链式调用。</p>
<p>Stream 流一般用于集合，对集合常见的操作有：<strong>Filter 过滤</strong>、<strong>Sorted 排序</strong>、<strong>Map 转换</strong>、<strong>Count 计数</strong>等。</p>

        </article>
        <section class="post-near">
            <ul>
                
                    <li>上一篇: <a href="/JUC/">JUC</a></li>
                
                
                    <li>下一篇: <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li>
                
            </ul>
        </section>
        
    
        <section class="post-author">
        
            <figure class="author-avatar">
                <img src="https://imgs.699pic.com/images/500/614/672.jpg!list1x.v2" alt="shengwei" />
            </figure>
        
            <div class="author-info">
                <h4>shengwei</h4>
                <p>一个编程爱好者</p>
            </div>
        </section>
    
    </div>
</main>

    <footer>
    <div class="buttons">
        <a class="to-top" href="#"></a>
    </div>
    <div class="wrap min">
        <section class="widget">
            <div class="row">
                <div class="col-m-4">
                    <h3 class="title-recent">最新文章：</h3>
                    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/Git+Docker+%E5%89%8D%E7%AB%AF/">Git+Docker+前端</a></li><li class="post-list-item"><a class="post-list-link" href="/RabbitMQ/">RabbitMQ</a></li><li class="post-list-item"><a class="post-list-link" href="/%E9%A1%B9%E7%9B%AE/">项目</a></li><li class="post-list-item"><a class="post-list-link" href="/Java17%E6%96%B0%E7%89%B9%E6%80%A7/">Java17新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="post-list-item"><a class="post-list-link" href="/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/">测试基础</a></li></ul>
                </div>
            </div>
        </section>
        <section class="sub-footer">
            <p>© 2024 <a href="/">Java后端与测试核心面试题总结</a>. All Rights Reserved. Theme By <a href="https://github.com/Dreamer-Paul/Hingle" target="_blank" rel="nofollow">Hingle</a>.</p>
        </section>
    </div>
</footer>


<script src="/static/kico.js"></script>
<script src="/static/hingle.js"></script>


<script>var hingle = new Paul_Hingle({"copyright":false,"night":false});</script>

  </body>
</html>
